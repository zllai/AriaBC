#include "postgres.h"
#include "bcdb/worker.h"
#include "bcdb/shm_transaction.h"
#include "bcdb/shm_block.h"
#include "bcdb/utils/cJSON.h"
#include "libpq/libpq.h"
#include <unistd.h>
#include <tcop/dest.h>
#include <utils/guc.h>
#include <tcop/tcopprot.h>
#include <pgstat.h>
#include <pg_trace.h>
#include <utils/palloc.h>
#include <utils/portal.h>
#include <utils/memutils.h>
#include <tcop/utility.h>
#include <utils/ps_status.h>
#include <miscadmin.h>
#include <utils/snapmgr.h>
#include <tcop/pquery.h>
#include <access/printtup.h>
#include <storage/ipc.h>
#include <executor/executor.h>
#include <assert.h>
#include <storage/predicate.h>
#include "bcdb/middleware.h"
#include "bcdb/globals.h"
#include "bcdb/bcdb_dsa.h"
#include "bcdb/shm_block.h"
#include "storage/condition_variable.h"
#include "pgstat.h"
#include "parser/analyze.h"
#include <unistd.h>
#include "access/heapam.h"
#include <time.h>
#include <stdlib.h>

int current_block_id;
MemoryContext bcdb_tx_context;
MemoryContext bcdb_worker_context;

static void get_write_set(BCDBShmXact *tx, Snapshot snapshot);

BCBlockID 
GetCurrentTxBlockId(void)
{
    if (activeTx == NULL)
        return 0;
    return activeTx->block_id_committed;
}

BCBlockID
GetCurrentTxBlockIdSnapshot(void)
{
    if (activeTx == NULL)
        return 0;
    return activeTx->block_id_snapshot;
}

bool
bcdb_worker_init(void)
{
    MemoryContext old_context;
    ereport(DEBUG3,
        (errmsg("[ZL] worker(%d) initializing", getpid())));
    bcdb_worker_context = 
        AllocSetContextCreate(TopMemoryContext, 
                              "bcdb worker memory context", 
                              ALLOCSET_DEFAULT_SIZES);
    bcdb_tx_context = 
        AllocSetContextCreate(TopMemoryContext, 
                              "bcdb transaction memory context", 
                              ALLOCSET_DEFAULT_SIZES);
    old_context = MemoryContextSwitchTo(bcdb_worker_context);
    MemoryContextSwitchTo(old_context);
    pid = getpid();
    srand(pid);
    if (OEP_mode)
        DEBUGNOCHECK("[ZL] worker runing is OEP mode");
    return true;
}


void
get_write_set(BCDBShmXact *tx, Snapshot snapshot) {
    const char *query_string = tx->sql;

    CommandDest dest = whereToSendOutput;
    MemoryContext oldcontext;
    List *parsetree_list;
    ListCell *parsetree_item;
    bool save_log_statement_stats = log_statement_stats;
    bool use_implicit_block;
    const char *commandTag;
    char completionTag[COMPLETION_TAG_BUFSIZE];
    MemoryContext per_parsetree_context = NULL;
    List *querytree_list,
         *plantree_list;
    Portal portal;
    DestReceiver *receiver;
    int16 format;
    RawStmt *parsetree;
    bool snapshot_set = false;

    /*
     * Report query to various monitoring facilities.
     */
    debug_query_string = query_string;
    activeTx->start_parsing_time = bcdb_get_time();
    pgstat_report_activity(STATE_RUNNING, query_string);

    TRACE_POSTGRESQL_QUERY_START(query_string);

    /*
     * We use save_log_statement_stats so ShowUsage doesn't report incorrect
     * results because ResetUsage wasn't called.
     */
    if (save_log_statement_stats)
        ResetUsage();

    /*
     * Start up a transaction command.  All queries generated by the
     * query_string will be in this same command block, *unless* we find a
     * BEGIN/COMMIT/ABORT statement; we have to force a new xact command after
     * one of those, else bad things will happen in xact.c. (Note that this
     * will normally change current memory context.)
     */
//    start_new_tx_state();
//    start_xact_command();
//    if (snapshot == NULL) {
//        snapshot = GetTransactionSnapshot();
//    }
//    PushActiveSnapshot(snapshot);

    /*
     * Zap any pre-existing unnamed statement.  (While not strictly necessary,
     * it seems best to define simple-Query mode as if it used the unnamed
     * statement and portal; this ensures we recover any storage used by prior
     * unnamed operations.)
     */
    drop_unnamed_stmt();

    /*
     * Switch to appropriate context for constructing parsetrees.
     */
    oldcontext = MemoryContextSwitchTo(MessageContext);

    /*
     * Do basic parsing of the query or queries (this should be safe even if
     * we are in aborted transaction state!)
     */
    parsetree_list = pg_parse_query(query_string);

    /* Log immediately if dictated by log_statement */
    if (check_log_statement(parsetree_list)) {
        ereport(LOG,
                (errmsg("statement: %s", query_string),
                        errhidestmt(true),
                        errdetail_execute(parsetree_list)));
    }

    /*
     * Switch back to transaction context to enter the loop.
     */
    MemoryContextSwitchTo(oldcontext);

    /*
     * For historical reasons, if multiple SQL statements are given in a
     * single "simple Query" message, we execute them as a single transaction,
     * unless explicit transaction control commands are included to make
     * portions of the list be separate transactions.  To represent this
     * behavior properly in the transaction machinery, we use an "implicit"
     * transaction block.
     */
    use_implicit_block = (list_length(parsetree_list) > 1);

    /*
     * Run through the raw parsetree(s) and process each one.
     */
    assert(parsetree_list->length==1);
    parsetree_item = parsetree_list->elements;
    parsetree = lfirst_node(RawStmt, parsetree_item);

    //chris: snapshot is fixed @ the beginning
    

    /*
     * Get the command name for use in status display (it also becomes the
     * default completion tag, down inside PortalRun).  Set ps_status and
     * do any special start-of-SQL-command processing needed by the
     * destination.
     */
    commandTag = CreateCommandTag(parsetree->stmt);

    set_ps_display(commandTag, false);

    BeginCommand(commandTag, dest);

    /*
     * If we are in an aborted transaction, reject all commands except
     * COMMIT/ABORT.  It is important that this test occur before we try
     * to do parse analysis, rewrite, or planning, since all those phases
     * try to do database accesses, which may fail in abort state. (It
     * might be safe to allow some additional utility commands in this
     * state, but not many...)
     */
//        if (IsAbortedTransactionBlockState() &&
//            !IsTransactionExitStmt(parsetree->stmt))
//            ereport(ERROR,
//                    (errcode(ERRCODE_IN_FAILED_SQL_TRANSACTION),
//                            errmsg("current transaction is aborted, "
//                                   "commands ignored until end of transaction block"),
//                            errdetail_abort()));

    /* Make sure we are in a transaction command */
//        start_xact_command();

    /*
     * If using an implicit transaction block, and we're not already in a
     * transaction block, start an implicit block to force this statement
     * to be grouped together with any following ones.  (We must do this
     * each time through the loop; otherwise, a COMMIT/ROLLBACK in the
     * list would cause later statements to not be grouped.)
     */
    if (use_implicit_block)
        BeginImplicitTransactionBlock();

    /* If we got a cancel signal in parsing or prior command, quit */
    CHECK_FOR_INTERRUPTS();

//        /*
//         * Set up a snapshot if parse analysis/planning will need one.
//         */
    if (analyze_requires_snapshot(parsetree))
    {
        PushActiveSnapshot(snapshot);
        snapshot_set = true;
    }

    /*
     * OK to analyze, rewrite, and plan this query.
     *
     * Switch to appropriate context for constructing query and plan trees
     * (these can't be in the transaction context, as that will get reset
     * when the command is COMMIT/ROLLBACK).  If we have multiple
     * parsetrees, we use a separate context for each one, so that we can
     * free that memory before moving on to the next one.  But for the
     * last (or only) parsetree, just use MessageContext, which will be
     * reset shortly after completion anyway.  In event of an error, the
     * per_parsetree_context will be deleted when MessageContext is reset.
     */
    if (lnext(parsetree_list, parsetree_item) != NULL) {
        per_parsetree_context =
                AllocSetContextCreate(MessageContext,
                                      "per-parsetree message context",
                                      ALLOCSET_DEFAULT_SIZES);
        oldcontext = MemoryContextSwitchTo(per_parsetree_context);
    } else
        oldcontext = MemoryContextSwitchTo(MessageContext);

    querytree_list = pg_analyze_and_rewrite(parsetree, query_string,
                                            NULL, 0, NULL); 
 

    plantree_list = pg_plan_queries(querytree_list,
                                    CURSOR_OPT_PARALLEL_OK, NULL);

    /* Done with the snapshot used for parsing/planning */
    if (snapshot_set)
        PopActiveSnapshot();

    /* If we got a cancel signal in analysis or planning, quit */
    CHECK_FOR_INTERRUPTS();

    /*
     * Create unnamed portal to run the query or queries in. If there
     * already is one, silently drop it.
     */
    portal = CreatePortal("", true, true);
    /* Don't display the portal in pg_cursors */
    portal->visible = false;

    /*
     * We don't have to copy anything into the portal, because everything
     * we are passing here is in MessageContext or the
     * per_parsetree_context, and so will outlive the portal anyway.
     */
    PortalDefineQuery(portal,
                      NULL,
                      query_string,
                      commandTag,
                      plantree_list,
                      NULL);
    activeTx->end_parsing_time = bcdb_get_time();

    /*
     * Start the portal.  No parameters here.
     * chris: I fix the snapshot here
     */
    PortalStart(portal, NULL, 0, snapshot);

    /*
     * Select the appropriate output format: text unless we are doing a
     * FETCH from a binary cursor.  (Pretty grotty to have to do this here
     * --- but it avoids grottiness in other places.  Ah, the joys of
     * backward compatibility...)
     */
    format = 0;                /* TEXT is default */
    if (IsA(parsetree->stmt, FetchStmt)) {
        FetchStmt *stmt = (FetchStmt *) parsetree->stmt;

        if (!stmt->ismove) {
            Portal fportal = GetPortalByName(stmt->portalname);

            if (PortalIsValid(fportal) &&
                (fportal->cursorOptions & CURSOR_OPT_BINARY))
                format = 1; /* BINARY */
        }
    }
    PortalSetResultFormat(portal, 1, &format);

    /*
     * Now we can create the destination receiver object.
     */
    receiver = CreateDestReceiver(dest);
    if (dest == DestRemote)
        SetRemoteDestReceiverParams(receiver, portal);

    /*
     * Switch back to transaction context for execution.
     */
    MemoryContextSwitchTo(oldcontext);

    (void) PortalRun(portal,
                     FETCH_ALL,
                     true,    /* always top level */
                     true,
                     receiver,
                     receiver,
                     completionTag);
    activeTx->portal = portal;

    MemoryContextSwitchTo(oldcontext);
}

void
bcdb_worker_process_tx(BCDBShmXact *tx)
{
    BCBlock     *block = NULL;
    Snapshot     snapshot;
    ResourceOwner old_owner;
    int32        num_ready;
    int32        num_finished;
    bool         timing = rand() % 10 == 0;

    Assert(tx != NULL);
    tx->worker_pid = pid;
    activeTx = tx;
    DEBUGMSG("[ZL] tx %s scheduled on worker: %d", tx->hash, tx->worker_pid);

    WaitGlobalBmin(tx->block_id_committed);
    tx->block_id_snapshot = tx->block_id_committed - 1;

    DEBUGMSG("[ZL] tx %s snapshot %d", tx->hash, tx->block_id_snapshot);
    LIST_INIT(&ws_table_record);
    LIST_INIT(&rs_table_record);

    PG_TRY();
    {
        XactIsoLevel = tx->isolation;
        tx->status = TX_EXECUTING;
        if (timing)
            tx->start_simulation_time = bcdb_get_time();
        start_xact_command();
        snapshot = GetTransactionSnapshot();
        tx->sxact = ShareSerializableXact();
        tx->sxact->bcdb_tx = tx;
        get_write_set(tx, snapshot);
        old_owner = CurrentResourceOwner;
        CurrentResourceOwner = activeTx->portal->resowner;
        ExecutorFinish(tx->queryDesc);
        ExecutorEnd(tx->queryDesc);
        FreeQueryDesc(tx->queryDesc);
        CurrentResourceOwner = old_owner;
        PortalDrop(activeTx->portal, false);

        if (block == NULL)
        {
            block = get_block_by_id(tx->block_id_committed, false);
            Assert(block != NULL);
        }
        tx->status = TX_WAIT_FOR_COMMIT;

    	num_ready = __sync_add_and_fetch(&block->num_ready, 1);
        DEBUGMSG("[ZL] tx %s waiting with num_ready: %d", tx->hash, num_ready);
        if (num_ready == block->num_tx)
            ConditionVariableBroadcast(&block->cond);

        if (timing)
            tx->end_simulation_time = bcdb_get_time();

        WaitCondition(&block->cond, block->num_tx == block->num_ready);

        if (timing)
            tx->start_checking_time = bcdb_get_time();

        tx->status = TX_COMMITTING;

        if (SxactIsDoomed(activeTx->sxact))
			ereport(ERROR,
				(errcode(ERRCODE_T_R_SERIALIZATION_FAILURE),
				 errmsg("doomed (tx: %s) after conflict check", activeTx->hash),
				 errdetail_internal("probably failed during conflict checking.")));

        conflict_check();
        if (timing)
            tx->end_checking_time = bcdb_get_time();
        apply_optim_writes();
        if (timing)
            tx->end_local_copy_time = bcdb_get_time();
        tx->sxact->flags |= SXACT_FLAG_PREPARED;
        finish_xact_command();

        DEBUGMSG("[ZL] worker(%d) commiting tx(%s)", getpid(), tx->hash);
        tx->status = TX_COMMITED;
        num_finished = __sync_add_and_fetch(&block->num_finished, 1);
        DEBUGMSG("[ZL] tx %s finishing with num_finish: %d", tx->hash, num_finished);
        if (num_finished == block->num_tx)
        {
            uint32 global_bmin;
            int32  block_committed = 0;
            BCDBShmXact *tx_iter;
            unsigned char tx_state_hash[SHA256_DIGEST_LENGTH];
            SHA256_CTX block_state_hash;
            unsigned char final_block_state_hash[SHA256_DIGEST_LENGTH];
            char *block_hash_b64;

            clean_rs_ws_table();
            global_bmin = __sync_add_and_fetch(&block_meta->global_bmin, 1);
            
            ConditionVariableBroadcast(&block_meta->conds[global_bmin % NUM_BMIN_COND]);
            DEBUGMSG("[ZL] tx %s incrementing bmin to: %d", activeTx->hash, global_bmin);
            SHA256_Init(&block_state_hash);
            for (int i=0; i < block->num_tx; i++)
            {
                tx_iter = block->txs[i];
                if (tx_iter->status == TX_COMMITED)
                {
                    block_committed += 1;
                    SHA256_Final(tx_state_hash, &tx_iter->state_hash);
                    SHA256_Update(&block_state_hash, tx_state_hash, SHA256_DIGEST_LENGTH);
                }
            }
            SHA256_Final(final_block_state_hash, &block_state_hash);
            Base64Encode(final_block_state_hash, SHA256_DIGEST_LENGTH, &block_hash_b64);
            ereport(LOG, (errmsg("[ZL] block %d hash: %s", block->id, block_hash_b64)));
    	    __sync_fetch_and_add(&block_meta->num_committed, block_committed);
    	    __sync_fetch_and_add(&block_meta->num_aborted, block->num_tx - block_committed);
            block_cleaning(block->id);
        }
        if (tx->create_time != 0)
            tx->commit_time = bcdb_get_time();

        if (timing)
            tx->commit_time = bcdb_get_time();
        MemoryContextReset(bcdb_tx_context);
        if (timing)
            ereport(LOG, (errmsg("[ZL] tx (%s) runtime: %lu, parsing: %lu, simulation: %lu, wait: %lu, check: %lu, apply: %lu, commit %lu", tx->hash, 
                                tx->commit_time - tx->start_simulation_time,
                                tx->end_parsing_time - tx->start_parsing_time,
                                tx->end_simulation_time - tx->start_simulation_time,
                                tx->start_checking_time - tx->end_simulation_time,
                                tx->end_checking_time - tx->start_checking_time,
                                tx->end_local_copy_time - tx->end_checking_time,
                                tx->commit_time - tx->end_local_copy_time)));  
        if (tx->create_time != 0)
            ereport(LOG, (errmsg("[ZL] tx (%s) latency: %lu", tx->hash, tx->commit_time - tx->create_time)));  
    }
    PG_CATCH();
    {
		OptimWriteEntry *optim_write_entry;

        while ((optim_write_entry = SIMPLEQ_FIRST(&activeTx->optim_write_list)))
        {
            ExecDropSingleTupleTableSlot(optim_write_entry->slot);
            SIMPLEQ_REMOVE_HEAD(&activeTx->optim_write_list, link);
        }
        PG_RE_THROW();
    }
    PG_END_TRY();
}


void
bcdb_on_worker_exit(int code, Datum arg)
{
    /* clean up here */
}


